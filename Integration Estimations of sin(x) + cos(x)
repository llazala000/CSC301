{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 13,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "  Exact Value    Trapezoid Estimation    Absolute Error    Relative Error\n",
      "-------------  ----------------------  ----------------  ----------------\n",
      "      1.56042                 1.25553          0.304886          0.242835\n",
      "\n",
      " The results of this estimation are consistent with what I expected. The absolute and relative error is larger than the other  estimations, which makes sense since approximating with the area of the trapezoids doesn't seem like it would be the most precise.\n",
      "\n",
      "\n",
      "  Exact Value    Riemann Sum Estimation    Absolute Error    Relative Error\n",
      "-------------  ------------------------  ----------------  ----------------\n",
      "      1.56042                   1.55065        0.00976988        0.00630053\n",
      "\n",
      " The results of this estimation are consistent as well. The larger the value of n is, the more accurate the  estimation would be. For the sake of uniformity I chose n = 100 for all of my estimations but I'm sure that if I  used 1000 as the value of n, the absolute error and relative error would be significantly smaller or close  to nonexistent, as it is pretty small as it is. \n",
      "\n",
      "\n",
      "  Exact Value    Simpson's Rule Estimation    Absolute Error    Relative Error\n",
      "-------------  ---------------------------  ----------------  ----------------\n",
      "      1.56042                      1.53674         0.0236806         0.0154097\n",
      "\n",
      " The results of this estimation were pretty close to the exact value. The absolute error was not the largest  and neither was  the relative error. \n",
      "\n",
      "\n",
      "  Exact Value    Monte Carlo Estimation    Absolute Error    Relative Error\n",
      "-------------  ------------------------  ----------------  ----------------\n",
      "      1.56042                    1.5732        -0.0127806       -0.00812394\n",
      "\n",
      " The results of this estimation are the most accurate since it has the smallest absolute and relative errors of the  estimation methods used. \n"
     ]
    }
   ],
   "source": [
    "import math\n",
    "import numpy as np\n",
    "from tabulate import tabulate\n",
    "\n",
    "#Estimations of the integral of (sin(x)+cos(x))\n",
    "# from 0.4 radians to 1.6 radians\n",
    "\n",
    "def integral(a, b): #gives exact value of integral\n",
    "    s = (math.cos(b) - math.sin(b)) - (math.cos(a) - math.sin(a))\n",
    "    return abs(s)\n",
    "\n",
    "exact_val = integral(0.4, 1.6)\n",
    "TrapAbsErr = list()\n",
    "TrapRelErr = list()\n",
    "RieAbsErr = list()\n",
    "RieRelErr = list()\n",
    "MCAbsErr = list()\n",
    "MCRelErr = list()\n",
    "SimpAbsErr = list()\n",
    "SimpRelErr = list()\n",
    "\n",
    "def trapezoid_int(f, g, a, b, n):\n",
    "    h = (b-a)/float(n)\n",
    "    s = 0.0\n",
    "    for i in range (0,n):\n",
    "        k = 0.5 * h * ((f(a + i*h) + g(a + i*h))+ (f(a + (i+1)*h) + g(a + (i+1))))\n",
    "        s = s + k\n",
    "    abserr = exact_val - s\n",
    "    TrapAbsErr.append(abserr)\n",
    "    TrapRelErr.append(abserr / s)\n",
    "    return s\n",
    "\n",
    "def riemann_int(f,g,a,b,n):\n",
    "    s = 0\n",
    "    h = (b-a)/n\n",
    "    for i in range(0,n-1):\n",
    "        k= a + i*h\n",
    "        s = s + ((f(k) + g(k)) * h)\n",
    "    abserr = exact_val - s\n",
    "    RieAbsErr.append(abserr)\n",
    "    RieRelErr.append(abserr / s)\n",
    "    return s\n",
    "\n",
    "def simpson_int(f, g, a, b, n):\n",
    "    if b < a: \n",
    "        a,b = b,a\n",
    "    h = (b-a)/n\n",
    "    m = n/2\n",
    "    s = 0.0\n",
    "    if (n % 2 == 0):\n",
    "        for i in range (1, int(m-1)):\n",
    "            x = a + 2*i*h\n",
    "            s = s + (2 * (f(x)+g(x)))\n",
    "        for i in range(1, int(m)):\n",
    "            x = a + (2*i-1) * h\n",
    "            s = s + (4 * (f(x)+ g(x)))\n",
    "        s = h * (s + (f(a)+g(a)) + (f(b)+g(b))) / 3\n",
    "    else: \n",
    "        return 0\n",
    "    abserr = exact_val - s\n",
    "    SimpAbsErr.append(abserr)\n",
    "    SimpRelErr.append(abserr / s)\n",
    "    return s\n",
    "\n",
    "def montecarlo_int(f, g, a, b, n):\n",
    "    s = 0.0\n",
    "    h = (b-a)/n\n",
    "    my_range = np.random.uniform(a,b,n)\n",
    "    for i in my_range: \n",
    "        i = float(i)\n",
    "        s = s + (f(i)+g(i))\n",
    "    s = h * s\n",
    "    abserr = exact_val - s\n",
    "    MCAbsErr.append(abserr)\n",
    "    MCRelErr.append(abserr / s)\n",
    "    return s\n",
    "\n",
    "\n",
    "print(tabulate([[exact_val, trapezoid_int(math.sin, math.cos, 0.4, 1.6, 100), TrapAbsErr[0], TrapRelErr[0] ]], \n",
    "               headers=['Exact Value','Trapezoid Estimation', 'Absolute Error', \"Relative Error\"]))\n",
    "print(\"\\n The results of this estimation are consistent with what I expected. The absolute and relative error is larger than\",\n",
    "     \"the other  estimations, which makes sense since approximating with the area of the trapezoids doesn't seem like\",\n",
    "     \"it would be the most precise.\")\n",
    "print(\"\\n\")\n",
    "\n",
    "print(tabulate([[exact_val, riemann_int(math.sin, math.cos, 0.4, 1.6, 100), RieAbsErr[0], RieRelErr[0] ]], \n",
    "               headers=['Exact Value','Riemann Sum Estimation', 'Absolute Error', \"Relative Error\"]))\n",
    "print(\"\\n The results of this estimation are consistent as well. The larger the value of n is, the more accurate the\",\n",
    "     \" estimation would be. For the sake of uniformity I chose n = 100 for all of my estimations but I'm sure that if I\",\n",
    "     \" used 1000 as the value of n, the absolute error and relative error would be significantly smaller or close\",\n",
    "      \" to nonexistent, as it is pretty small as it is. \")\n",
    "print(\"\\n\")\n",
    "\n",
    "print(tabulate([[exact_val, simpson_int(math.sin, math.cos, 0.4, 1.6, 100), SimpAbsErr[0], SimpRelErr[0] ]], \n",
    "               headers=['Exact Value',\"Simpson's Rule Estimation\", 'Absolute Error', \"Relative Error\"]))\n",
    "print(\"\\n The results of this estimation were pretty close to the exact value. The absolute error was not the largest\",\n",
    "     \" and neither was  the relative error. \")\n",
    "print(\"\\n\")\n",
    "\n",
    "print(tabulate([[exact_val, montecarlo_int(math.sin, math.cos, 0.4, 1.6, 100), MCAbsErr[0], MCRelErr[0] ]], \n",
    "               headers=['Exact Value','Monte Carlo Estimation', 'Absolute Error', \"Relative Error\"]))\n",
    "print(\"\\n The results of this estimation are the most accurate since it has the smallest absolute and relative errors of the\",\n",
    "     \" estimation methods used. \")\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.7.1"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
